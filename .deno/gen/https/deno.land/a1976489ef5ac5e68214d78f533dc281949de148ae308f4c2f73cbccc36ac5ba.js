export function crc32(arr) {
    if (typeof arr === "string") {
        arr = new TextEncoder().encode(arr);
    }
    let crc = -1, i, j, l, temp, poly = 3988292384;
    for(i = 0, l = arr.length; i < l; i += 1){
        temp = (crc ^ arr[i]) & 255;
        for(j = 0; j < 8; j += 1){
            if ((temp & 1) === 1) {
                temp = temp >>> 1 ^ poly;
            } else {
                temp = temp >>> 1;
            }
        }
        crc = crc >>> 8 ^ temp;
    }
    return numberToHex(crc ^ -1);
}
export class Crc32Stream {
    bytes = [];
    poly = 3988292384;
    crc = 0 ^ -1;
    encoder = new TextEncoder();
    #crc32 = "";
    constructor(){
        this.reset();
    }
    get crc32() {
        return this.#crc32;
    }
    reset() {
        this.#crc32 = "";
        this.crc = 0 ^ -1;
        for(let n = 0; n < 256; n += 1){
            let c = n;
            for(let k = 0; k < 8; k += 1){
                if (c & 1) {
                    c = this.poly ^ c >>> 1;
                } else {
                    c = c >>> 1;
                }
            }
            this.bytes[n] = c >>> 0;
        }
    }
    append(arr) {
        if (typeof arr === "string") {
            arr = this.encoder.encode(arr);
        }
        let crc = this.crc;
        for(let i = 0, l = arr.length; i < l; i += 1){
            crc = crc >>> 8 ^ this.bytes[(crc ^ arr[i]) & 255];
        }
        this.crc = crc;
        this.#crc32 = numberToHex(crc ^ -1);
        return this.#crc32;
    }
}
export function numberToHex(n) {
    return (n >>> 0).toString(16);
}
export function hexToUint8Array(str) {
    if (str.length === 0 || str.length % 2 !== 0) {
        throw new Error(`The string "${str}" is not valid hex.`);
    }
    return new Uint8Array(str.match(/.{1,2}/g).map((byte)=>parseInt(byte, 16)
    ));
}
export function uint8ArrayToHex(bytes) {
    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, "0")
    , "");
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxodHRwczovL2Rlbm8ubGFuZC94L2NyYzMyQHYwLjIuMC9tb2QudHM+Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBjcmMzMihhcnI6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGFyciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShhcnIpO1xuICB9XG4gIGxldCBjcmMgPSAtMSwgaSwgaiwgbCwgdGVtcCwgcG9seSA9IDB4RURCODgzMjA7XG5cbiAgZm9yIChpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICB0ZW1wID0gKGNyYyBeIGFycltpXSkgJiAweGZmO1xuICAgIGZvciAoaiA9IDA7IGogPCA4OyBqICs9IDEpIHtcbiAgICAgIGlmICgodGVtcCAmIDEpID09PSAxKSB7XG4gICAgICAgIHRlbXAgPSAodGVtcCA+Pj4gMSkgXiBwb2x5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9ICh0ZW1wID4+PiAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0ZW1wO1xuICB9XG5cbiAgcmV0dXJuIG51bWJlclRvSGV4KGNyYyBeIC0xKTtcbn1cblxuZXhwb3J0IGNsYXNzIENyYzMyU3RyZWFtIHtcbiAgcHJpdmF0ZSBieXRlczogbnVtYmVyW10gPSBbXTtcbiAgcHJpdmF0ZSBwb2x5ID0gMHhFREI4ODMyMDtcbiAgcHJpdmF0ZSBjcmMgPSAwIF4gLTE7XG4gIHByaXZhdGUgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAjY3JjMzI6IHN0cmluZyA9IFwiXCI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgZ2V0IGNyYzMyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuI2NyYzMyO1xuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy4jY3JjMzIgPSBcIlwiO1xuICAgIHRoaXMuY3JjID0gMCBeIC0xO1xuXG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAyNTY7IG4gKz0gMSkge1xuICAgICAgbGV0IGMgPSBuO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrICs9IDEpIHtcbiAgICAgICAgaWYgKGMgJiAxKSB7XG4gICAgICAgICAgYyA9IHRoaXMucG9seSBeIChjID4+PiAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjID0gYyA+Pj4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ieXRlc1tuXSA9IGMgPj4+IDA7XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKGFycjogVWludDhBcnJheSB8IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGFyciA9IHRoaXMuZW5jb2Rlci5lbmNvZGUoYXJyKTtcbiAgICB9XG5cbiAgICBsZXQgY3JjID0gdGhpcy5jcmM7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGhpcy5ieXRlc1soY3JjIF4gYXJyW2ldKSAmIDB4ZmZdO1xuICAgIH1cblxuICAgIHRoaXMuY3JjID0gY3JjO1xuICAgIHRoaXMuI2NyYzMyID0gbnVtYmVyVG9IZXgoY3JjIF4gLTEpO1xuICAgIHJldHVybiB0aGlzLiNjcmMzMjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXgobjogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIChuID4+PiAwKS50b1N0cmluZygxNik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1VpbnQ4QXJyYXkoc3RyOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgc3RyLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdHJpbmcgXCIke3N0cn1cIiBpcyBub3QgdmFsaWQgaGV4LmApO1xuICB9XG4gIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICBzdHIubWF0Y2goLy57MSwyfS9nKSEubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvSGV4KGJ5dGVzOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZShcbiAgICAoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksXG4gICAgXCJcIixcbiAgKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiZ0JBQWdCLEtBQUssQ0FBQyxHQUF3QjtlQUNqQyxHQUFHLE1BQUssTUFBUTtRQUN6QixHQUFHLE9BQU8sV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHOztRQUVoQyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEdBQUcsVUFBVTtRQUV6QyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7UUFDdkMsSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUk7WUFDdkIsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO2lCQUNsQixJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUM7Z0JBQ2xCLElBQUksR0FBSSxJQUFJLEtBQUssQ0FBQyxHQUFJLElBQUk7O2dCQUUxQixJQUFJLEdBQUksSUFBSSxLQUFLLENBQUM7OztRQUd0QixHQUFHLEdBQUksR0FBRyxLQUFLLENBQUMsR0FBSSxJQUFJOztXQUduQixXQUFXLENBQUMsR0FBRyxJQUFJLENBQUM7O2FBR2hCLFdBQVc7SUFDZCxLQUFLO0lBQ0wsSUFBSSxHQUFHLFVBQVU7SUFDakIsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDO0lBQ1osT0FBTyxPQUFPLFdBQVc7S0FDaEMsS0FBSzs7YUFHQyxLQUFLOztRQUdSLEtBQUs7cUJBQ00sS0FBSzs7SUFHcEIsS0FBSztjQUNHLEtBQUs7YUFDTixHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7Z0JBRVIsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO2dCQUN6QixDQUFDLEdBQUcsQ0FBQztvQkFDQSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7b0JBQ3ZCLENBQUMsR0FBRyxDQUFDO29CQUNQLENBQUMsUUFBUSxJQUFJLEdBQUksQ0FBQyxLQUFLLENBQUM7O29CQUV4QixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7OztpQkFHVixLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDOzs7SUFJM0IsTUFBTSxDQUFDLEdBQXdCO21CQUNsQixHQUFHLE1BQUssTUFBUTtZQUN6QixHQUFHLFFBQVEsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHOztZQUczQixHQUFHLFFBQVEsR0FBRztnQkFFVCxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7WUFDM0MsR0FBRyxHQUFJLEdBQUcsS0FBSyxDQUFDLFFBQVMsS0FBSyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxLQUFLLEdBQUk7O2FBR2pELEdBQUcsR0FBRyxHQUFHO2NBQ1IsS0FBSyxHQUFHLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQztxQkFDckIsS0FBSzs7O2dCQUlOLFdBQVcsQ0FBQyxDQUFTO1lBQzNCLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxDQUFDLEVBQUU7O2dCQUdkLGVBQWUsQ0FBQyxHQUFXO1FBQ3JDLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUM7a0JBQ2hDLEtBQUssRUFBRSxZQUFZLEVBQUUsR0FBRyxDQUFDLG1CQUFtQjs7ZUFFN0MsVUFBVSxDQUNuQixHQUFHLENBQUMsS0FBSyxZQUFhLEdBQUcsRUFBRSxJQUFJLEdBQUssUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFOzs7Z0JBSXpDLGVBQWUsQ0FBQyxLQUFpQjtXQUN4QyxLQUFLLENBQUMsTUFBTSxFQUNoQixHQUFHLEVBQUUsSUFBSSxHQUFLLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQyxHQUFFLENBQUcifQ==