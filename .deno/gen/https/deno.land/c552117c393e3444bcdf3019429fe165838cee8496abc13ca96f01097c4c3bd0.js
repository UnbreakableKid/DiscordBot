import { crc32 } from "../deps.ts";
/** very fast */ import { deflateRaw, inflateRaw } from "../zlib/mod.ts";
/** slow */ // import { deflateRaw, inflateRaw } from "../deflate/mod.ts";
// magic numbers marking this file as GZIP
const ID1 = 31;
const ID2 = 139;
const compressionMethods = {
    "deflate": 8
};
const possibleFlags = {
    "FTEXT": 1,
    "FHCRC": 2,
    "FEXTRA": 4,
    "FNAME": 8,
    "FCOMMENT": 16
};
// const osMap = {
//   "fat": 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS
//   "amiga": 1, // Amiga
//   "vmz": 2, // VMS (VAX or Alpha AXP)
//   "unix": 3, // Unix
//   "vm/cms": 4, // VM/CMS
//   "atari": 5, // Atari
//   "hpfs": 6, // HPFS file system (OS/2, NT 3.x)
//   "macintosh": 7, // Macintosh
//   "z-system": 8, // Z-System
//   "cplm": 9, // CP/M
//   "tops-20": 10, // TOPS-20
//   "ntfs": 11, // NTFS file system (NT)
//   "qdos": 12, // SMS/QDOS
//   "acorn": 13, // Acorn RISC OS
//   "vfat": 14, // VFAT file system (Win95, NT)
//   "vms": 15, // MVS (code also taken for PRIMOS)
//   "beos": 16, // BeOS (BeBox or PowerMac)
//   "tandem": 17, // Tandem/NSK
//   "theos": 18, // THEOS
// };
const os = {
    "darwin": 3,
    "linux": 3,
    "windows": 0
};
const osCode = os[Deno.build.os] ?? 255;
export const DEFAULT_LEVEL = 6;
function putByte(n, arr) {
    arr.push(n & 255);
}
// LSB first
function putShort(n, arr) {
    arr.push(n & 255);
    arr.push(n >>> 8);
}
// LSB first
export function putLong(n, arr) {
    putShort(n & 65535, arr);
    putShort(n >>> 16, arr);
}
function putString(s, arr) {
    for(let i = 0, len = s.length; i < len; i += 1){
        putByte(s.charCodeAt(i), arr);
    }
}
function readByte(arr) {
    return arr.shift();
}
function readShort(arr) {
    return arr.shift() | arr.shift() << 8;
}
function readLong(arr) {
    let n1 = readShort(arr);
    let n2 = readShort(arr);
    // JavaScript can't handle bits in the position 32
    // we'll emulate this by removing the left-most bit (if it exists)
    // and add it back in via multiplication, which does work
    if (n2 > 32768) {
        n2 -= 32768;
        return (n2 << 16 | n1) + 32768 * Math.pow(2, 16);
    }
    return n2 << 16 | n1;
}
function readString(arr) {
    const charArr = [];
    // turn all bytes into chars until the terminating null
    while(arr[0] !== 0){
        charArr.push(String.fromCharCode(arr.shift()));
    }
    // throw away terminating null
    arr.shift();
    // join all characters into a cohesive string
    return charArr.join("");
}
function readBytes(arr, n) {
    const ret = [];
    for(let i = 0; i < n; i += 1){
        ret.push(arr.shift());
    }
    return ret;
}
export function getHeader(options = {
}) {
    let flags = 0;
    let level = options.level ?? DEFAULT_LEVEL;
    const out = [];
    putByte(ID1, out);
    putByte(ID2, out);
    putByte(compressionMethods["deflate"], out);
    if (options.name) {
        flags |= possibleFlags["FNAME"];
    }
    putByte(flags, out);
    putLong(options.timestamp ?? Math.floor(Date.now() / 1000), out);
    // put deflate args (extra flags)
    if (level === 1) {
        // fastest algorithm
        putByte(4, out);
    } else if (level === 9) {
        // maximum compression (fastest algorithm)
        putByte(2, out);
    } else {
        putByte(0, out);
    }
    // OS identifier
    putByte(osCode, out);
    if (options.name) {
        // ignore the directory part
        putString(options.name.substring(options.name.lastIndexOf("/") + 1), out);
        // terminating null
        putByte(0, out);
    }
    return new Uint8Array(out);
}
export function gzip(bytes, options = {
}) {
    let flags = 0;
    let level = options.level ?? DEFAULT_LEVEL;
    const out = [];
    putByte(ID1, out);
    putByte(ID2, out);
    putByte(compressionMethods["deflate"], out);
    if (options.name) {
        flags |= possibleFlags["FNAME"];
    }
    putByte(flags, out);
    putLong(options.timestamp ?? Math.floor(Date.now() / 1000), out);
    // put deflate args (extra flags)
    if (level === 1) {
        // fastest algorithm
        putByte(4, out);
    } else if (level === 9) {
        // maximum compression (fastest algorithm)
        putByte(2, out);
    } else {
        putByte(0, out);
    }
    // OS identifier
    putByte(osCode, out);
    if (options.name) {
        // ignore the directory part
        putString(options.name.substring(options.name.lastIndexOf("/") + 1), out);
        // terminating null
        putByte(0, out);
    }
    deflateRaw(bytes).forEach(function(byte) {
        putByte(byte, out);
    });
    // import { deflateRaw, inflateRaw } from "../deflate/mod.ts";
    // deflateRaw(bytes, level).forEach(function (byte) {
    //   putByte(byte, out);
    // });
    putLong(parseInt(crc32(bytes), 16), out);
    putLong(bytes.length, out);
    return new Uint8Array(out);
}
export function gunzip(bytes) {
    const arr = Array.from(bytes);
    checkHeader(arr);
    // give deflate everything but the last 8 bytes
    // the last 8 bytes are for the CRC32 checksum and filesize
    let res = inflateRaw(new Uint8Array(arr.splice(0, arr.length - 8)));
    // if (flags & possibleFlags["FTEXT"]) {
    //   res = Array.prototype.map.call(res, function (byte) {
    //     return String.fromCharCode(byte);
    //   }).join("");
    // }
    let crc = readLong(arr) >>> 0;
    if (crc !== parseInt(crc32(res), 16)) {
        throw "Checksum does not match";
    }
    let size = readLong(arr);
    if (size !== res.length) {
        throw "Size of decompressed file not correct";
    }
    return res;
}
export function checkHeader(arr) {
    // check the first two bytes for the magic numbers
    if (readByte(arr) !== ID1 || readByte(arr) !== ID2) {
        throw "Not a GZIP file";
    }
    if (readByte(arr) !== 8) {
        throw "Unsupported compression method";
    }
    let flags = readByte(arr);
    readLong(arr); // mtime
    readByte(arr); // xFlags
    readByte(arr); // os, throw away
    // just throw away the bytes for now
    if (flags & possibleFlags["FEXTRA"]) {
        let t = readShort(arr);
        readBytes(arr, t);
    }
    // just throw away for now
    if (flags & possibleFlags["FNAME"]) {
        readString(arr);
    }
    // just throw away for now
    if (flags & possibleFlags["FCOMMENT"]) {
        readString(arr);
    }
    // just throw away for now
    if (flags & possibleFlags["FHCRC"]) {
        readShort(arr);
    }
}
export function checkTail(arr) {
    const tail = arr.splice(arr.length - 8);
    let crc32 = readLong(tail) >>> 0;
    let size = readLong(tail);
    return {
        crc32,
        size
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxodHRwczovL2Rlbm8ubGFuZC94L2NvbXByZXNzQHYwLjMuNi9nemlwL2d6aXAudHM+Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyYzMyIH0gZnJvbSBcIi4uL2RlcHMudHNcIjtcbi8qKiB2ZXJ5IGZhc3QgKi9cbmltcG9ydCB7IGRlZmxhdGVSYXcsIGluZmxhdGVSYXcgfSBmcm9tIFwiLi4vemxpYi9tb2QudHNcIjtcbi8qKiBzbG93ICovXG4vLyBpbXBvcnQgeyBkZWZsYXRlUmF3LCBpbmZsYXRlUmF3IH0gZnJvbSBcIi4uL2RlZmxhdGUvbW9kLnRzXCI7XG5cbi8vIG1hZ2ljIG51bWJlcnMgbWFya2luZyB0aGlzIGZpbGUgYXMgR1pJUFxuY29uc3QgSUQxID0gMHgxRjtcbmNvbnN0IElEMiA9IDB4OEI7XG5cbmNvbnN0IGNvbXByZXNzaW9uTWV0aG9kcyA9IHtcbiAgXCJkZWZsYXRlXCI6IDgsXG59O1xuY29uc3QgcG9zc2libGVGbGFncyA9IHtcbiAgXCJGVEVYVFwiOiAweDAxLFxuICBcIkZIQ1JDXCI6IDB4MDIsXG4gIFwiRkVYVFJBXCI6IDB4MDQsXG4gIFwiRk5BTUVcIjogMHgwOCxcbiAgXCJGQ09NTUVOVFwiOiAweDEwLFxufTtcbi8vIGNvbnN0IG9zTWFwID0ge1xuLy8gICBcImZhdFwiOiAwLCAvLyBGQVQgZmlsZSBzeXN0ZW0gKERPUywgT1MvMiwgTlQpICsgUEtaSVBXIDIuNTAgVkZBVCwgTlRGU1xuLy8gICBcImFtaWdhXCI6IDEsIC8vIEFtaWdhXG4vLyAgIFwidm16XCI6IDIsIC8vIFZNUyAoVkFYIG9yIEFscGhhIEFYUClcbi8vICAgXCJ1bml4XCI6IDMsIC8vIFVuaXhcbi8vICAgXCJ2bS9jbXNcIjogNCwgLy8gVk0vQ01TXG4vLyAgIFwiYXRhcmlcIjogNSwgLy8gQXRhcmlcbi8vICAgXCJocGZzXCI6IDYsIC8vIEhQRlMgZmlsZSBzeXN0ZW0gKE9TLzIsIE5UIDMueClcbi8vICAgXCJtYWNpbnRvc2hcIjogNywgLy8gTWFjaW50b3NoXG4vLyAgIFwiei1zeXN0ZW1cIjogOCwgLy8gWi1TeXN0ZW1cbi8vICAgXCJjcGxtXCI6IDksIC8vIENQL01cbi8vICAgXCJ0b3BzLTIwXCI6IDEwLCAvLyBUT1BTLTIwXG4vLyAgIFwibnRmc1wiOiAxMSwgLy8gTlRGUyBmaWxlIHN5c3RlbSAoTlQpXG4vLyAgIFwicWRvc1wiOiAxMiwgLy8gU01TL1FET1Ncbi8vICAgXCJhY29yblwiOiAxMywgLy8gQWNvcm4gUklTQyBPU1xuLy8gICBcInZmYXRcIjogMTQsIC8vIFZGQVQgZmlsZSBzeXN0ZW0gKFdpbjk1LCBOVClcbi8vICAgXCJ2bXNcIjogMTUsIC8vIE1WUyAoY29kZSBhbHNvIHRha2VuIGZvciBQUklNT1MpXG4vLyAgIFwiYmVvc1wiOiAxNiwgLy8gQmVPUyAoQmVCb3ggb3IgUG93ZXJNYWMpXG4vLyAgIFwidGFuZGVtXCI6IDE3LCAvLyBUYW5kZW0vTlNLXG4vLyAgIFwidGhlb3NcIjogMTgsIC8vIFRIRU9TXG4vLyB9O1xuY29uc3Qgb3MgPSB7XG4gIFwiZGFyd2luXCI6IDMsXG4gIFwibGludXhcIjogMyxcbiAgXCJ3aW5kb3dzXCI6IDAsXG59O1xuXG5jb25zdCBvc0NvZGUgPSBvc1tEZW5vLmJ1aWxkLm9zXSA/PyAyNTU7XG5leHBvcnQgY29uc3QgREVGQVVMVF9MRVZFTCA9IDY7XG5cbmZ1bmN0aW9uIHB1dEJ5dGUobjogbnVtYmVyLCBhcnI6IG51bWJlcltdKSB7XG4gIGFyci5wdXNoKG4gJiAweEZGKTtcbn1cblxuLy8gTFNCIGZpcnN0XG5mdW5jdGlvbiBwdXRTaG9ydChuOiBudW1iZXIsIGFycjogbnVtYmVyW10pIHtcbiAgYXJyLnB1c2gobiAmIDB4RkYpO1xuICBhcnIucHVzaChuID4+PiA4KTtcbn1cblxuLy8gTFNCIGZpcnN0XG5leHBvcnQgZnVuY3Rpb24gcHV0TG9uZyhuOiBudW1iZXIsIGFycjogbnVtYmVyW10pIHtcbiAgcHV0U2hvcnQobiAmIDB4ZmZmZiwgYXJyKTtcbiAgcHV0U2hvcnQobiA+Pj4gMTYsIGFycik7XG59XG5cbmZ1bmN0aW9uIHB1dFN0cmluZyhzOiBzdHJpbmcsIGFycjogbnVtYmVyW10pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBwdXRCeXRlKHMuY2hhckNvZGVBdChpKSwgYXJyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkQnl0ZShhcnI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgcmV0dXJuIGFyci5zaGlmdCgpITtcbn1cblxuZnVuY3Rpb24gcmVhZFNob3J0KGFycjogbnVtYmVyW10pIHtcbiAgcmV0dXJuIGFyci5zaGlmdCgpISB8IChhcnIuc2hpZnQoKSEgPDwgOCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRMb25nKGFycjogbnVtYmVyW10pIHtcbiAgbGV0IG4xID0gcmVhZFNob3J0KGFycik7XG4gIGxldCBuMiA9IHJlYWRTaG9ydChhcnIpO1xuXG4gIC8vIEphdmFTY3JpcHQgY2FuJ3QgaGFuZGxlIGJpdHMgaW4gdGhlIHBvc2l0aW9uIDMyXG4gIC8vIHdlJ2xsIGVtdWxhdGUgdGhpcyBieSByZW1vdmluZyB0aGUgbGVmdC1tb3N0IGJpdCAoaWYgaXQgZXhpc3RzKVxuICAvLyBhbmQgYWRkIGl0IGJhY2sgaW4gdmlhIG11bHRpcGxpY2F0aW9uLCB3aGljaCBkb2VzIHdvcmtcbiAgaWYgKG4yID4gMzI3NjgpIHtcbiAgICBuMiAtPSAzMjc2ODtcblxuICAgIHJldHVybiAoKG4yIDw8IDE2KSB8IG4xKSArIDMyNzY4ICogTWF0aC5wb3coMiwgMTYpO1xuICB9XG5cbiAgcmV0dXJuIChuMiA8PCAxNikgfCBuMTtcbn1cblxuZnVuY3Rpb24gcmVhZFN0cmluZyhhcnI6IG51bWJlcltdKSB7XG4gIGNvbnN0IGNoYXJBcnIgPSBbXTtcblxuICAvLyB0dXJuIGFsbCBieXRlcyBpbnRvIGNoYXJzIHVudGlsIHRoZSB0ZXJtaW5hdGluZyBudWxsXG4gIHdoaWxlIChhcnJbMF0gIT09IDApIHtcbiAgICBjaGFyQXJyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhcnIuc2hpZnQoKSEpKTtcbiAgfVxuXG4gIC8vIHRocm93IGF3YXkgdGVybWluYXRpbmcgbnVsbFxuICBhcnIuc2hpZnQoKTtcblxuICAvLyBqb2luIGFsbCBjaGFyYWN0ZXJzIGludG8gYSBjb2hlc2l2ZSBzdHJpbmdcbiAgcmV0dXJuIGNoYXJBcnIuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJ5dGVzKGFycjogbnVtYmVyW10sIG46IG51bWJlcikge1xuICBjb25zdCByZXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICByZXQucHVzaChhcnIuc2hpZnQoKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuaW50ZXJmYWNlIE9wdGlvbnMge1xuICBsZXZlbD86IG51bWJlcjtcbiAgdGltZXN0YW1wPzogbnVtYmVyO1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGVhZGVyKFxuICBvcHRpb25zOiBPcHRpb25zID0ge30sXG4pOiBVaW50OEFycmF5IHtcbiAgbGV0IGZsYWdzOiBudW1iZXIgPSAwO1xuICBsZXQgbGV2ZWw6IG51bWJlciA9IG9wdGlvbnMubGV2ZWwgPz8gREVGQVVMVF9MRVZFTDtcbiAgY29uc3Qgb3V0OiBudW1iZXJbXSA9IFtdO1xuXG4gIHB1dEJ5dGUoSUQxLCBvdXQpO1xuICBwdXRCeXRlKElEMiwgb3V0KTtcblxuICBwdXRCeXRlKGNvbXByZXNzaW9uTWV0aG9kc1tcImRlZmxhdGVcIl0sIG91dCk7XG5cbiAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgIGZsYWdzIHw9IHBvc3NpYmxlRmxhZ3NbXCJGTkFNRVwiXTtcbiAgfVxuXG4gIHB1dEJ5dGUoZmxhZ3MsIG91dCk7XG4gIHB1dExvbmcob3B0aW9ucy50aW1lc3RhbXAgPz8gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksIG91dCk7XG5cbiAgLy8gcHV0IGRlZmxhdGUgYXJncyAoZXh0cmEgZmxhZ3MpXG4gIGlmIChsZXZlbCA9PT0gMSkge1xuICAgIC8vIGZhc3Rlc3QgYWxnb3JpdGhtXG4gICAgcHV0Qnl0ZSg0LCBvdXQpO1xuICB9IGVsc2UgaWYgKGxldmVsID09PSA5KSB7XG4gICAgLy8gbWF4aW11bSBjb21wcmVzc2lvbiAoZmFzdGVzdCBhbGdvcml0aG0pXG4gICAgcHV0Qnl0ZSgyLCBvdXQpO1xuICB9IGVsc2Uge1xuICAgIHB1dEJ5dGUoMCwgb3V0KTtcbiAgfVxuXG4gIC8vIE9TIGlkZW50aWZpZXJcbiAgcHV0Qnl0ZShvc0NvZGUsIG91dCk7XG5cbiAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgIC8vIGlnbm9yZSB0aGUgZGlyZWN0b3J5IHBhcnRcbiAgICBwdXRTdHJpbmcob3B0aW9ucy5uYW1lLnN1YnN0cmluZyhvcHRpb25zLm5hbWUubGFzdEluZGV4T2YoXCIvXCIpICsgMSksIG91dCk7XG5cbiAgICAvLyB0ZXJtaW5hdGluZyBudWxsXG4gICAgcHV0Qnl0ZSgwLCBvdXQpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG91dCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnemlwKFxuICBieXRlczogVWludDhBcnJheSxcbiAgb3B0aW9uczogT3B0aW9ucyA9IHt9LFxuKTogVWludDhBcnJheSB7XG4gIGxldCBmbGFnczogbnVtYmVyID0gMDtcbiAgbGV0IGxldmVsOiBudW1iZXIgPSBvcHRpb25zLmxldmVsID8/IERFRkFVTFRfTEVWRUw7XG4gIGNvbnN0IG91dDogbnVtYmVyW10gPSBbXTtcblxuICBwdXRCeXRlKElEMSwgb3V0KTtcbiAgcHV0Qnl0ZShJRDIsIG91dCk7XG5cbiAgcHV0Qnl0ZShjb21wcmVzc2lvbk1ldGhvZHNbXCJkZWZsYXRlXCJdLCBvdXQpO1xuXG4gIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICBmbGFncyB8PSBwb3NzaWJsZUZsYWdzW1wiRk5BTUVcIl07XG4gIH1cblxuICBwdXRCeXRlKGZsYWdzLCBvdXQpO1xuICBwdXRMb25nKG9wdGlvbnMudGltZXN0YW1wID8/IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLCBvdXQpO1xuXG4gIC8vIHB1dCBkZWZsYXRlIGFyZ3MgKGV4dHJhIGZsYWdzKVxuICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAvLyBmYXN0ZXN0IGFsZ29yaXRobVxuICAgIHB1dEJ5dGUoNCwgb3V0KTtcbiAgfSBlbHNlIGlmIChsZXZlbCA9PT0gOSkge1xuICAgIC8vIG1heGltdW0gY29tcHJlc3Npb24gKGZhc3Rlc3QgYWxnb3JpdGhtKVxuICAgIHB1dEJ5dGUoMiwgb3V0KTtcbiAgfSBlbHNlIHtcbiAgICBwdXRCeXRlKDAsIG91dCk7XG4gIH1cblxuICAvLyBPUyBpZGVudGlmaWVyXG4gIHB1dEJ5dGUob3NDb2RlLCBvdXQpO1xuXG4gIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBpZ25vcmUgdGhlIGRpcmVjdG9yeSBwYXJ0XG4gICAgcHV0U3RyaW5nKG9wdGlvbnMubmFtZS5zdWJzdHJpbmcob3B0aW9ucy5uYW1lLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpLCBvdXQpO1xuXG4gICAgLy8gdGVybWluYXRpbmcgbnVsbFxuICAgIHB1dEJ5dGUoMCwgb3V0KTtcbiAgfVxuXG4gIGRlZmxhdGVSYXcoYnl0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGJ5dGUpIHtcbiAgICBwdXRCeXRlKGJ5dGUsIG91dCk7XG4gIH0pO1xuICAvLyBpbXBvcnQgeyBkZWZsYXRlUmF3LCBpbmZsYXRlUmF3IH0gZnJvbSBcIi4uL2RlZmxhdGUvbW9kLnRzXCI7XG4gIC8vIGRlZmxhdGVSYXcoYnl0ZXMsIGxldmVsKS5mb3JFYWNoKGZ1bmN0aW9uIChieXRlKSB7XG4gIC8vICAgcHV0Qnl0ZShieXRlLCBvdXQpO1xuICAvLyB9KTtcblxuICBwdXRMb25nKHBhcnNlSW50KGNyYzMyKGJ5dGVzKSwgMTYpLCBvdXQpO1xuICBwdXRMb25nKGJ5dGVzLmxlbmd0aCwgb3V0KTtcblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkob3V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcChieXRlczogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBhcnIgPSBBcnJheS5mcm9tKGJ5dGVzKTtcblxuICBjaGVja0hlYWRlcihhcnIpO1xuXG4gIC8vIGdpdmUgZGVmbGF0ZSBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCA4IGJ5dGVzXG4gIC8vIHRoZSBsYXN0IDggYnl0ZXMgYXJlIGZvciB0aGUgQ1JDMzIgY2hlY2tzdW0gYW5kIGZpbGVzaXplXG4gIGxldCByZXM6IFVpbnQ4QXJyYXkgPSBpbmZsYXRlUmF3KFxuICAgIG5ldyBVaW50OEFycmF5KGFyci5zcGxpY2UoMCwgYXJyLmxlbmd0aCAtIDgpKSxcbiAgKTtcblxuICAvLyBpZiAoZmxhZ3MgJiBwb3NzaWJsZUZsYWdzW1wiRlRFWFRcIl0pIHtcbiAgLy8gICByZXMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwocmVzLCBmdW5jdGlvbiAoYnl0ZSkge1xuICAvLyAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSk7XG4gIC8vICAgfSkuam9pbihcIlwiKTtcbiAgLy8gfVxuXG4gIGxldCBjcmM6IG51bWJlciA9IHJlYWRMb25nKGFycikgPj4+IDA7XG4gIGlmIChjcmMgIT09IHBhcnNlSW50KGNyYzMyKHJlcyksIDE2KSkge1xuICAgIHRocm93IFwiQ2hlY2tzdW0gZG9lcyBub3QgbWF0Y2hcIjtcbiAgfVxuXG4gIGxldCBzaXplOiBudW1iZXIgPSByZWFkTG9uZyhhcnIpO1xuICBpZiAoc2l6ZSAhPT0gcmVzLmxlbmd0aCkge1xuICAgIHRocm93IFwiU2l6ZSBvZiBkZWNvbXByZXNzZWQgZmlsZSBub3QgY29ycmVjdFwiO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSGVhZGVyKGFycjogbnVtYmVyW10pIHtcbiAgLy8gY2hlY2sgdGhlIGZpcnN0IHR3byBieXRlcyBmb3IgdGhlIG1hZ2ljIG51bWJlcnNcbiAgaWYgKHJlYWRCeXRlKGFycikgIT09IElEMSB8fCByZWFkQnl0ZShhcnIpICE9PSBJRDIpIHtcbiAgICB0aHJvdyBcIk5vdCBhIEdaSVAgZmlsZVwiO1xuICB9XG4gIGlmIChyZWFkQnl0ZShhcnIpICE9PSA4KSB7XG4gICAgdGhyb3cgXCJVbnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2RcIjtcbiAgfVxuXG4gIGxldCBmbGFnczogbnVtYmVyID0gcmVhZEJ5dGUoYXJyKTtcbiAgcmVhZExvbmcoYXJyKTsgLy8gbXRpbWVcbiAgcmVhZEJ5dGUoYXJyKTsgLy8geEZsYWdzXG4gIHJlYWRCeXRlKGFycik7IC8vIG9zLCB0aHJvdyBhd2F5XG5cbiAgLy8ganVzdCB0aHJvdyBhd2F5IHRoZSBieXRlcyBmb3Igbm93XG4gIGlmIChmbGFncyAmIHBvc3NpYmxlRmxhZ3NbXCJGRVhUUkFcIl0pIHtcbiAgICBsZXQgdDogbnVtYmVyID0gcmVhZFNob3J0KGFycik7XG4gICAgcmVhZEJ5dGVzKGFyciwgdCk7XG4gIH1cblxuICAvLyBqdXN0IHRocm93IGF3YXkgZm9yIG5vd1xuICBpZiAoZmxhZ3MgJiBwb3NzaWJsZUZsYWdzW1wiRk5BTUVcIl0pIHtcbiAgICByZWFkU3RyaW5nKGFycik7XG4gIH1cblxuICAvLyBqdXN0IHRocm93IGF3YXkgZm9yIG5vd1xuICBpZiAoZmxhZ3MgJiBwb3NzaWJsZUZsYWdzW1wiRkNPTU1FTlRcIl0pIHtcbiAgICByZWFkU3RyaW5nKGFycik7XG4gIH1cblxuICAvLyBqdXN0IHRocm93IGF3YXkgZm9yIG5vd1xuICBpZiAoZmxhZ3MgJiBwb3NzaWJsZUZsYWdzW1wiRkhDUkNcIl0pIHtcbiAgICByZWFkU2hvcnQoYXJyKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tUYWlsKGFycjogbnVtYmVyW10pIHtcbiAgY29uc3QgdGFpbCA9IGFyci5zcGxpY2UoYXJyLmxlbmd0aCAtIDgpO1xuXG4gIGxldCBjcmMzMjogbnVtYmVyID0gcmVhZExvbmcodGFpbCkgPj4+IDA7XG4gIGxldCBzaXplOiBudW1iZXIgPSByZWFkTG9uZyh0YWlsKTtcblxuICByZXR1cm4ge1xuICAgIGNyYzMyLFxuICAgIHNpemUsXG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IlNBQVMsS0FBSyxTQUFRLFVBQVk7QUFDbEMsRUFBZ0IsQUFBaEIsWUFBZ0IsQUFBaEIsRUFBZ0IsVUFDUCxVQUFVLEVBQUUsVUFBVSxTQUFRLGNBQWdCO0FBQ3ZELEVBQVcsQUFBWCxPQUFXLEFBQVgsRUFBVyxDQUNYLEVBQThELEFBQTlELDREQUE4RDtBQUU5RCxFQUEwQyxBQUExQyx3Q0FBMEM7TUFDcEMsR0FBRyxHQUFHLEVBQUk7TUFDVixHQUFHLEdBQUcsR0FBSTtNQUVWLGtCQUFrQjtLQUN0QixPQUFTLEdBQUUsQ0FBQzs7TUFFUixhQUFhO0tBQ2pCLEtBQU8sR0FBRSxDQUFJO0tBQ2IsS0FBTyxHQUFFLENBQUk7S0FDYixNQUFRLEdBQUUsQ0FBSTtLQUNkLEtBQU8sR0FBRSxDQUFJO0tBQ2IsUUFBVSxHQUFFLEVBQUk7O0FBRWxCLEVBQWtCLEFBQWxCLGdCQUFrQjtBQUNsQixFQUEwRSxBQUExRSx3RUFBMEU7QUFDMUUsRUFBeUIsQUFBekIsdUJBQXlCO0FBQ3pCLEVBQXdDLEFBQXhDLHNDQUF3QztBQUN4QyxFQUF1QixBQUF2QixxQkFBdUI7QUFDdkIsRUFBMkIsQUFBM0IseUJBQTJCO0FBQzNCLEVBQXlCLEFBQXpCLHVCQUF5QjtBQUN6QixFQUFrRCxBQUFsRCxnREFBa0Q7QUFDbEQsRUFBaUMsQUFBakMsK0JBQWlDO0FBQ2pDLEVBQStCLEFBQS9CLDZCQUErQjtBQUMvQixFQUF1QixBQUF2QixxQkFBdUI7QUFDdkIsRUFBOEIsQUFBOUIsNEJBQThCO0FBQzlCLEVBQXlDLEFBQXpDLHVDQUF5QztBQUN6QyxFQUE0QixBQUE1QiwwQkFBNEI7QUFDNUIsRUFBa0MsQUFBbEMsZ0NBQWtDO0FBQ2xDLEVBQWdELEFBQWhELDhDQUFnRDtBQUNoRCxFQUFtRCxBQUFuRCxpREFBbUQ7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